(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{229:function(n,t,s){"use strict";s.r(t);var a=s(0),i=Object(a.a)({},(function(){var n=this,t=n.$createElement,s=n._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"this的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this的理解"}},[n._v("#")]),n._v(" this的理解")]),n._v(" "),s("h2",{attrs:{id:"this的指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this的指向"}},[n._v("#")]),n._v(" this的指向")]),n._v(" "),s("ol",[s("li",[n._v("函数调用")]),n._v(" "),s("li",[n._v("全局作用域里this的指向")]),n._v(" "),s("li",[n._v("call/apply/bind 可以改变函数运行时的this指向")]),n._v(" "),s("li",[n._v("es6箭头函数")])]),n._v(" "),s("h3",{attrs:{id:"函数调用时-this的指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数调用时-this的指向"}},[n._v("#")]),n._v(" 函数调用时 this的指向")]),n._v(" "),s("ol",[s("li",[n._v("函数预编译时 this的指向是指向于window")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function fun(a,b){\n\tvar a =1;\n\tconsole.log(this)  //window\n\tconsole.log(this.a) //undefined\n}\nfun(2)\n\n此时的AO (预编译时)\n{\n\targuments : [2,undefined],\n\tthis: window,   \n\ta:2\n\tb:undefined\n}\n\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[n._v("函数被调用时的this指向"),s("br"),n._v("\n列子一")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("\n<script>\nfunction fun(){\n\tconsole.log(this)\n}\nfun()  // window \n\n解析一下：\n因为此时fun是在全局的环境下 *被* 调用的。 \n其实声明函数时 等于在window上面声明了该函数\n此时的： fun()  === window.fun()\n<\/script>\n")])])]),s("p",[n._v("列子二")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("<script>\nvar obj = {\n\tfun : function(){\n\t\tconsole.log(this.name)\n\t},\n\tname: '111'\n}\nobj.fun()   // 111\n\n解析一下： 同理，此时fun是被obj调用，所以此时的this指向的是obj\n\n<\/script>\n")])])]),s("p",[n._v("列子三")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("<script>\nvar obj = {\n\tfun : function(){\n\t\tconsole.log(this)\n\t},\n\tname: '111',\t\t\t\t\n\tfunTwo : function(callBack){\n\t\tcallBack()\n\t}\n}\nobj.funTwo(obj.fun)    //window\n \n 解析一下：\n1.  funTwo 函数接受的参数是一个函数 是obj.fun ，但此时并没有被调用，只是将这个函数的地址传递了过去，\n此时依然处于预编译的状态，this指向的是window\n2.  在调用时 callBack调用了 fun指向的地址，此时调用的函数与obj并没有直接调用关系，所以this依然指向的是window\n<\/script>\n\n")])])]),s("p",[n._v("注意：")]),n._v(" "),s("ol",[s("li",[n._v("在严格模式下，this将保持他进入执行环境时的值，所以下面的this将会默认为undefined")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('function fun(){\n  "use strict"; // 这里是严格模式\n  return this;  \n}\nfun() === undefined; // true\n')])])]),s("h3",{attrs:{id:"全局作用域里this的指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#全局作用域里this的指向"}},[n._v("#")]),n._v(" 全局作用域里this的指向")]),n._v(" "),s("p",[n._v("这里不提，上面已经提到了，全局作用域里时this会默认指向window")]),n._v(" "),s("h3",{attrs:{id:"call-apply-bind-可以改变函数运行时的this指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind-可以改变函数运行时的this指向"}},[n._v("#")]),n._v(" call/apply/bind 可以改变函数运行时的this指向")]),n._v(" "),s("p",[n._v("call/apply : 可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。\nbind : bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。")]),n._v(" "),s("p",[n._v("call/apply : 两个作用一样，区别在于第二个参数，apply传参的是数组")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("<script>\nvar name = '111';\nvar obj = {\n\tname : '222'\n}\n\t\t\nfunction fun(a,b){\n\tconsole.log(a);\n\tconsole.log(b);\n\tconsole.log(this.name)\n}\nfun()  // undefined undefined 111 \nfun.call(obj,1,2) // 此时的 this 指向就是obj   1,2,222\nfun.apply(obj,[1,2])  //1,2,222 \n<\/script>\n")])])]),s("p",[n._v("bind : bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("<script>\nvar name = '111';\nvar obj = {\n\tname : '222'\n}\n\t\t\nfunction fun(a,b){\n\tconsole.log(a);\n\tconsole.log(b);\n\tconsole.log(this.name)\n}\n\nvar funTwo = fun.bind(obj)\nfun()  // undefined undefined 111 \nfunTwo(1,2)  //1,2,222   此时的 this 指向就是obj\n<\/script>\n")])])]),s("p",[n._v("注意：")]),n._v(" "),s("ol",[s("li",[n._v("call/apply 改变this指向以后并会立马执行")]),n._v(" "),s("li",[n._v("bind改变this以后会返回新的函数，并不会立马执行")])]),n._v(" "),s("h3",{attrs:{id:"es6箭头函数-的this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6箭头函数-的this"}},[n._v("#")]),n._v(" es6箭头函数 的this")]),n._v(" "),s("p",[n._v("重点（关于this方面的）：")]),n._v(" "),s("ol",[s("li",[n._v("es6箭头函数没有自己的this,函数里的this是外层代码的this")]),n._v(" "),s("li",[n._v("箭头函数的this是在定义函数时绑定的，不是在执行过程中绑定的。")]),n._v(" "),s("li",[n._v("箭头函数this是继承自父执行上下文，不是调用时的this。")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("//普通函数\nfunction fun(){\n\tconsole.log(this)\n}\nfun() //window\n\n//箭头函数\nlet fun = () =>{\n\tconsole.log(this)\n}\nfun() // window 因为此时fun是在全局定义的，父作用域 也就是父作用域的上下文 是window\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var obj = {\n\tfun : () =>{\n\t\tconsole.log(this)\n\t},\n\tname: '111',\t\t\t\t\n\tfunTwo : (callBack) = >{\n\t\tcallBack()\n\t}\n}\nobj.funTwo(obj.fun)   //window\n\n//解析一下：\n箭头函数的this是定义时绑定的，就是this是继承自父执行上下文\n此时的 fun 与 funTwo本身所在的对象是obj，是以key/value形式而已，obj父执行的上下文为window\n\n")])])]),s("p",[n._v("最后一个列子")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("//普通函數\nvar name = '111';\nvar obj = {\n\tname : '222',\n\tfun : function(){\n\t\tsetTimeout(function(){\n\t\t\tconsole.log(this.name) \n\t\t},100)\n\t}\n}\nobj.fun()  //111   \n\n解析：obj调用函数fun，此时fun里面的this是 obj，但是setTimeout是全局的window上的方法，\n所以其实等于 window.setTimeout()  所以里面的this指向了window\n\n//箭頭函數\nvar name = '111';\nvar obj = {\n\tname : '222',\n\tfun : function(){\n\t\tsetTimeout(()=>{\n\t\t\tconsole.log(this.name) \n\t\t},100)\n\t}\n}\nobj.fun()  //222\n\n解析：obj调用函数fun，此时fun里面的this是 obj，但是setTimeout是全局的window上的方法，\n但是 setTimeout方法在定义时的父执行上下文this为 obj ，所以此时的this为 obj\n\n")])])]),s("p",[n._v("注意：\n1.箭头函数通过call和apply调用，不会改变this指向，只会传入参数")])])}),[],!1,null,null,null);t.default=i.exports}}]);