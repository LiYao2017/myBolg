<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>宏观任务和微观任务的探讨 | 李尧技术博客</title>
    <meta name="description" content="myBlog">
    <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.7d12f3d4.css" as="style"><link rel="preload" href="/assets/js/app.db5fb402.js" as="script"><link rel="preload" href="/assets/js/2.c24a2de0.js" as="script"><link rel="preload" href="/assets/js/10.f77a8e98.js" as="script"><link rel="prefetch" href="/assets/js/11.7f933877.js"><link rel="prefetch" href="/assets/js/12.a56b9a6c.js"><link rel="prefetch" href="/assets/js/13.0c4c5845.js"><link rel="prefetch" href="/assets/js/14.844c7739.js"><link rel="prefetch" href="/assets/js/15.a67c9db5.js"><link rel="prefetch" href="/assets/js/16.c8b53757.js"><link rel="prefetch" href="/assets/js/17.3c2ecec7.js"><link rel="prefetch" href="/assets/js/18.77469b91.js"><link rel="prefetch" href="/assets/js/19.ae79786b.js"><link rel="prefetch" href="/assets/js/20.eac46a37.js"><link rel="prefetch" href="/assets/js/21.e070b06d.js"><link rel="prefetch" href="/assets/js/22.37ba754b.js"><link rel="prefetch" href="/assets/js/23.8732597c.js"><link rel="prefetch" href="/assets/js/24.22b92f61.js"><link rel="prefetch" href="/assets/js/25.1f94e81d.js"><link rel="prefetch" href="/assets/js/26.c1b21e1b.js"><link rel="prefetch" href="/assets/js/27.f0e2b455.js"><link rel="prefetch" href="/assets/js/28.85bf6cbb.js"><link rel="prefetch" href="/assets/js/29.d4bba7be.js"><link rel="prefetch" href="/assets/js/3.4b33e3ee.js"><link rel="prefetch" href="/assets/js/30.df5bee9d.js"><link rel="prefetch" href="/assets/js/4.65144aa1.js"><link rel="prefetch" href="/assets/js/5.3a30a02f.js"><link rel="prefetch" href="/assets/js/6.6ad79ddf.js"><link rel="prefetch" href="/assets/js/7.3a5ee693.js"><link rel="prefetch" href="/assets/js/8.3d7de5e6.js"><link rel="prefetch" href="/assets/js/9.156d964d.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7d12f3d4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">李尧技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/sidebar/" class="nav-link">学习-进阶</a></div><div class="nav-item"><a href="/config/" class="nav-link">难点-解析</a></div><div class="nav-item"><a href="/accumulate/" class="nav-link router-link-active">每日·积累</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><a href="/sidebar/" class="nav-link">学习-进阶</a></div><div class="nav-item"><a href="/config/" class="nav-link">难点-解析</a></div><div class="nav-item"><a href="/accumulate/" class="nav-link router-link-active">每日·积累</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/accumulate/" class="sidebar-link">面试题收集</a></li><li><a href="/accumulate/宏观任务和微观任务.html" class="active sidebar-link">宏观任务和微观任务的探讨</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/accumulate/宏观任务和微观任务.html#什么是宏观任务和微观任务" class="sidebar-link">什么是宏观任务和微观任务</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="宏观任务和微观任务的探讨"><a href="#宏观任务和微观任务的探讨" class="header-anchor">#</a> 宏观任务和微观任务的探讨</h1> <h2 id="什么是宏观任务和微观任务"><a href="#什么是宏观任务和微观任务" class="header-anchor">#</a> 什么是宏观任务和微观任务</h2> <blockquote><p>下面的概念 引用于 极客时间- winter老师的 重学前端中promise一文 (我觉得是目前网上最好的解释)</p></blockquote> <p>定义：我们把<strong>宿主发起的任务称为宏观任务</strong>，把<strong>javascript引擎发起的任务称为微观任务</strong>，<br>
微观任务执行顺序始终先于宏观任务，并且每个宏观任务可以包含多个微观任务。<br>
（纯属个人理解：宏观任务就是宿主环境的方法，微观任务就是js语言本身的方法）
javascript引擎执行的时候是一种事件循环的执行，在底层的C/C++代码中，这个时间循环是跑在独立线层中的循环，我们用伪代码表示，大概就是这样的：</p> <div class="language- extra-class"><pre class="language-text"><code>while(TRUE){
	r = wait();
	execute(r);
}

可以看到整个循环做的事情基本上就是反复的‘等待 - 执行’。当然，实际代码中没有那么简单，还有其他的判断。
</code></pre></div><p>所以理解为就是宏观任务就相当于一个事件的循环，等待着执行。<br>
而宏观任务中，javascript 的Promise 还会产生异步代码，javascript必须保证这些代码在一个宏观任务中完成，<br>
因此每个宏观任务又包含了一些微观任务，这些微观任务以列队的形式等待执行。
<img src="http://file.liyao1994.top/hongwei.jpg" alt="Alt text"></p> <h3 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h3> <p>promise 是javascript语言提供的一种标准化的异步管理方式。<br>
他的总体思想是需要进行io，等待或者其他异步操作的函数，不返回真实结果，而返回一个'承诺'，函数调用方可以在合适的时机，
选择等待这个承诺兑现(Promise的then方法的回调)<br>
首先基本用法：</p> <div class="language- extra-class"><pre class="language-text"><code> var r = new Promise(function(resolve, reject){
    console.log(&quot;a&quot;);
    resolve()
  });
  setTimeout(()=&gt;console.log(&quot;d&quot;), 0)
  r.then(() =&gt; console.log(&quot;c&quot;));
  console.log(&quot;b&quot;)
  
  执行结果： a , b , c
</code></pre></div><p>分析：r是一个promise 对象，进入console.log(b)之前，r已经拿到了resolve，但是因为异步操作的问题，所以c 无法出现在b之前</p> <p>promise 与 setTimeout的合用</p> <div class="language- extra-class"><pre class="language-text"><code>var r = new Promise(function(resolve, reject){
    console.log(&quot;a&quot;);
    resolve()
  });
  setTimeout(()=&gt;console.log(&quot;d&quot;), 0)
  r.then(() =&gt; console.log(&quot;c&quot;));
  console.log(&quot;b&quot;)
  //结果是： a , b , c ,d
</code></pre></div><p>分析：首先我们分析这里有多少个宏观任务，我们上面提到过，宏观任务的定义，和javascript的执行是队列执行，前面没执行完后面需要等待。<br>
首先这里有两个宏观任务：<br>
第一个宏观任务包括了console.log(a) 和console.log(b) 以及宏观里的微观console.log(c)<br>
第二个宏观任务也就是浏览器宿主发起的setTimeout，它包含的console.log(d)<br>
这里就不难理解输出的结果了</p> <blockquote><p>下面收集了知乎的一道题</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>  setTimeout(function(){console.log(4)},0); 
  new Promise(function(resolve){ 
    console.log(1) 
    for( var i=0 ; i&lt;10000 ; i++ ){
       i==9999 &amp;&amp; resolve() 
    } 
    console.log(2) 
  }).then(function(){ 
    console.log(5) 
  }); 
  console.log(3);
  
 // 输出结果 1 ，2 ，3 ，5 ，4
</code></pre></div><p>首先想想我们上面提到的宏观和微观任务的分辨，和javascript执行的队列机制。<br>
（纯属个人理解）<br>
1.分析这道题中的宏观和微观任务：
<img src="http://file.liyao1994.top/promise.png" alt="Alt text"><br>
a. 这道题有两个宏观任务，第一个为主环境默认的，第二个为setTimeout<br>
b. 根据微观任务一定先与宏观任务执行的特点，和队列机制 顺序执行的特点去分析<br>
首先执行 console.log(1) 然后是 console.log(2) 再是onsole.log(3)，两则执行完以后，再去执行异步的resolve() 也就是then中的  console.log(5)<br>
第一个宏观任务以及 宏观任务中的微观任务栈 全部执行完毕，再去执行队列中的第二位宏观任务，打印console.log(4)</p> <blockquote><p>根据上面引发的自我思考</p></blockquote> <ol><li>宏观任务是存储在 任务队列中的按照顺序的方式去执行，如果碰到异步的宏观则会调到下一个进行执行(类似多线程)</li></ol> <div class="language- extra-class"><pre class="language-text"><code>setTimeout(function(){console.log('a')},2000)
setTimeout(function(){console.log('b')},0)
//因为两个都是宏观任务，但是因为定时器的原因为异步，所以这个时候就是延顺到下一个，由时间去判断执行哪一个
</code></pre></div><ol start="2"><li>微观任务是存储是在执行栈中的，也是按照顺序依次执行(这是由javascript特性所决定的)，微观任务一定是优于宏观任务执行的。</li> <li>最初页面预编译的时候会将，宏观任务和微观任务进行分别的依次的储存，以入栈的形式。</li> <li>在执行过程中，微观任务中包含了宏观任务时，会将宏观任务入栈到 任务队列中，然后依次按照任务队列进行执行</li></ol> <div class="language- extra-class"><pre class="language-text"><code>setTimeout(function(){console.log(4)},0); 
Promise.resolve().then(function(){
	  console.log(1) 
	 setTimeout(function(){console.log(2)},0)
	}).then(function(){ 
	  console.log(5) 
})
console.log(3);
  
此时输出：3 ，1 ，5 ，4 ，2
分析：
首先预编译将宏观任务 和 微观任务进行 区分，
1. 然后执行第一个宏观任务的 微观任务：
console.log(3);
console.log(1)；-&gt;因为then的异步，所以放在第二位
到了这里发现了一个宏观任务 setTimeout ，将这个 宏观任务放入到 任务队列中，此时队列已经有了一个setTimeout，所以这个放入到它的下面一位
console.log(5) 
2. 执行完第一个以后，执行任务队列的第二个宏观任务
setTimeout(function(){console.log(4)},0); 
3.执行完第二个以后，执行任务队列的第三个宏观任务
 setTimeout(function(){console.log(2)},0)
</code></pre></div><h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async / await</h3> <p>async / await 是es6的新特性，它提供了for,if代码的结构方式。运行的基础是Promise,所以async函数必然返回的是Promise，
我们把所有返回的Promise的函数都可以认为是异步函数。</p> <ol><li>自动将常规函数转换成Promise，返回值也是一个Promise对象</li></ol> <div class="language- extra-class"><pre class="language-text"><code>async function foo(val){
   let a = 1;
	return val + a
}
foo(1);
//输出  Promise {&lt;resolved&gt;: 2}
所以
foo(1).then(function(e){console.log(e)})  //2

所以对于这里我们完全可以看
</code></pre></div><ol start="2"><li>只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数</li> <li>异步函数内部可以使用await</li></ol> <p>await</p> <ol><li>await 放置在Promise调用之前，await 强制后面点代码等待，直到Promise对象resolve，得到resolve的值作为await表达式的运算结果</li></ol> <div class="language- extra-class"><pre class="language-text"><code>function sleep(duration) {
    return new Promise(function(resolve, reject) {
        setTimeout(()=&gt;{console.log('111')},duration);
    })
}
async function foo(){
    console.log(&quot;a&quot;)
    await sleep(2000)
    console.log(&quot;b&quot;)
}
foo();  //输出a ,Promise {&lt;pending&gt;} ， （过2秒） 111
b不输出
</code></pre></div><ol start="2"><li>await只能在async函数内部使用,用在普通函数里就会报错</li></ol> <div class="language- extra-class"><pre class="language-text"><code>function sleep(duration) {
    return new Promise(function(resolve, reject) {
        setTimeout(resolve,duration);
    })
}
async function foo(){
    console.log(&quot;a&quot;)
    await sleep(2000)
    console.log(&quot;b&quot;)
}
foo();
//输出a , Promise {&lt;pending&gt;} ，（过2秒）b

</code></pre></div><ol start="3"><li><strong>重点重点</strong>很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await是一个让出线程的标志。
await后面的函数会先执行一遍，然后就会跳出整个async函数来执行后面js栈（后面会详述）的代码。
等本轮事件循环执行完了之后又会跳回到async函数中等待await。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>function foo1(){
	console.log('111')
}
async function foo(val){
   let a = 1;
	console.log('000');
   await foo1();
   console.log('222'); 
}
foo(1) 
console.log('333');

打印：000 111 333 222
</code></pre></div><p>接下来做一道题结束。</p> <blockquote><p>这是一道收集来的面试题        来源：木易杨说 高级面试题</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
	console.log('async2');
}

console.log('script start');

setTimeout(function() {
    console.log('setTimeout');
}, 0)

async1();

new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');

</code></pre></div><blockquote><p>下面来自本人的探讨和理解</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>首先输出的结果是：

script start  
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout

</code></pre></div><ol><li>首先有两个宏观任务 1.全局环境(自我认知) 2.setTimeout</li> <li>所以第一个执行 console.log('script start'); 再执行 async1();</li> <li>接下来就会打印 console.log('async1 start'); 立马去执行一次await的函数 打印console.log('async2');</li> <li>然后跳出执行其他js代码 也就是 下面new Promise 打印 console.log('promise1');</li> <li>然后因为异步所以打印console.log('script end');</li> <li>再跳转回去async1 里面 执行console.log('async1 end');</li> <li>再执行then的方法 console.log('promise2');</li> <li>最后执行第二个宏观任务 setTimeout 打印  console.log('setTimeout');</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/accumulate/" class="prev router-link-active">面试题收集</a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.db5fb402.js" defer></script><script src="/assets/js/2.c24a2de0.js" defer></script><script src="/assets/js/10.f77a8e98.js" defer></script>
  </body>
</html>
